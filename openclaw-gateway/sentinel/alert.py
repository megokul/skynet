"""
SKYNET Sentinel — Alert Dispatcher

Sends alerts to the operator via Telegram when health checks detect
issues.  Includes deduplication to prevent alert flooding.
"""

from __future__ import annotations

import logging
import time
from dataclasses import dataclass, field
from typing import Any, Callable, Awaitable

from .monitor import HealthStatus

logger = logging.getLogger("skynet.sentinel.alert")


@dataclass
class Alert:
    """An alert generated by the Sentinel."""

    component: str
    severity: str = "warning"      # info | warning | critical
    message: str = ""
    timestamp: float = field(default_factory=time.time)

    def to_dict(self) -> dict[str, Any]:
        return {
            "component": self.component,
            "severity": self.severity,
            "message": self.message,
            "timestamp": self.timestamp,
        }


class AlertDispatcher:
    """
    Dispatches alerts to configured channels (Telegram).

    Features:
      - Deduplication: same component alert suppressed for cooldown_seconds.
      - Severity filtering: only alerts above min_severity are dispatched.
    """

    def __init__(
        self,
        send_fn: Callable[[str], Awaitable[None]] | None = None,
        cooldown_seconds: int = 300,
        min_severity: str = "warning",
    ):
        self._send_fn = send_fn
        self.cooldown_seconds = cooldown_seconds
        self.min_severity = min_severity
        self._last_alert: dict[str, float] = {}
        self._alert_history: list[Alert] = []

    _SEVERITY_ORDER = {"info": 0, "warning": 1, "critical": 2}

    def should_alert(self, status: HealthStatus) -> bool:
        """Determine if a health status warrants an alert."""
        if status.healthy:
            return False

        # Check cooldown — don't spam same component.
        last = self._last_alert.get(status.component, 0)
        if time.time() - last < self.cooldown_seconds:
            return False

        return True

    def create_alert(self, status: HealthStatus) -> Alert:
        """Create an Alert from a failing HealthStatus."""
        severity = "critical" if "unreachable" in status.message.lower() else "warning"
        return Alert(
            component=status.component,
            severity=severity,
            message=f"{status.component}: {status.message}",
        )

    async def send_alert(self, alert: Alert) -> None:
        """Send alert to configured channel(s)."""
        # Check severity threshold.
        if self._SEVERITY_ORDER.get(alert.severity, 0) < self._SEVERITY_ORDER.get(self.min_severity, 0):
            return

        self._last_alert[alert.component] = time.time()
        self._alert_history.append(alert)

        # Keep history bounded.
        if len(self._alert_history) > 100:
            self._alert_history = self._alert_history[-50:]

        formatted = (
            f"SKYNET SENTINEL ALERT\n"
            f"[{alert.severity.upper()}] {alert.message}"
        )

        if self._send_fn:
            try:
                await self._send_fn(formatted)
                logger.info("Alert dispatched: %s", alert.message)
            except Exception as exc:
                logger.warning("Failed to dispatch alert: %s", exc)
        else:
            logger.warning("Alert (no send_fn): %s", alert.message)

    async def process_health_results(self, statuses: list[HealthStatus]) -> int:
        """Process health check results and send alerts for failing checks."""
        alerts_sent = 0
        for status in statuses:
            if self.should_alert(status):
                alert = self.create_alert(status)
                await self.send_alert(alert)
                alerts_sent += 1
        return alerts_sent

    @property
    def recent_alerts(self) -> list[Alert]:
        """Return recent alert history."""
        return list(self._alert_history[-20:])
